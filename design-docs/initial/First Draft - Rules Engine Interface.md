# Rules Engine Interface – First Draft

This document defines a **first-pass interface and contract** for the headless rules engine.

It is intentionally incomplete. The goal is to:
- make all assumptions explicit
- define clean seams between systems
- enable simulation, manual testing, and future UI

Nothing here is final.

---

## 0. Design Principles (Non‑Negotiable)

- **Headless**: no UI assumptions
- **Deterministic-first**: seedable RNG, replayable state transitions
- **Explicit**: no hidden rules or magic
- **Queryable**: the engine evaluates, never decides
- **Composable**: systems can be added without rewrites

---

## 1. Core Concepts

### 1.1 World State

The world state is a **pure data snapshot** at a point in time.

```ts
WorldState {
  time: TimeState
  map: MapState
  entities: EntityState[]
  players: PlayerState[]
  guilds: GuildState[]
  rng: RNGState
}
```

- WorldState must be serialisable
- WorldState transitions are only caused by Actions

---

### 1.2 Time Model

- Time is **discrete**
- Each action advances time by a fixed or computed amount

```ts
TimeState {
  currentTick: number
  sessionRemainingTicks: number
}
```

- A session ends when `sessionRemainingTicks <= 0`
- No concurrent actions in v1

---

### 1.3 RNG

```ts
RNGState {
  seed: string
  counters: Record<string, number>
}
```

- All randomness is routed through RNGState
- RNG draws are:
  - named
  - logged
  - inspectable

---

## 2. Player & Entity Model

### 2.1 Player State

```ts
PlayerState {
  id: PlayerID
  location: LocationID
  inventory: InventoryState
  skills: SkillState[]
  guildReputation: GuildRepState[]
  equipment: EquipmentState
  memory: AgentMemoryState
}
```

Notes:
- `memory` exists for simulation agents but is ignored by the game logic
- Equipment affects action outcomes but is not an action itself

---

### 2.2 Inventory State

```ts
InventoryState {
  containers: ContainerState[]
}

ContainerState {
  id: ContainerID
  type: ContainerType
  capacity: CapacityModel
  contents: ItemStack[]
}
```

- CapacityModel may be slot-based, weight-based, or hybrid (TBD)
- Inventory overflow is illegal; actions must fail or spill

---

### 2.3 Items

```ts
Item {
  id: ItemID
  category: ItemCategory
  stackable: boolean
  properties: ItemProperties
}
```

---

## 3. Actions

### 3.1 Action Contract

All changes to WorldState happen via Actions.

```ts
Action {
  id: ActionID
  actor: PlayerID
  type: ActionType
  parameters: Record<string, any>
}
```

Every Action must define:
- Preconditions
- Time cost
- RNG draws (if any)
- State transitions
- Failure modes

---

### 3.2 Action Result

```ts
ActionResult {
  success: boolean
  timeCost: number
  stateDelta: WorldDelta
  rngOutcomes: RNGLog[]
  failureReason?: string
}
```

---

### 3.3 Core Action Categories (v1)

- Move
- Gather
- Craft
- Fight
- Store / Retrieve
- AcceptContract
- CompleteContract

(Exact schemas TBD)

---

## 4. Contracts (Procedural Quests)

```ts
Contract {
  id: ContractID
  issuingGuild: GuildID
  objective: ObjectiveSpec
  rewards: RewardSpec
  modifiers: ContractModifiers
}
```

- Contracts are generated by the engine
- Agents/players choose whether to accept

---

## 5. Evaluation & Query APIs

The engine **does not recommend actions**, but can evaluate hypothetical plans.

### 5.1 Action Evaluation

```ts
evaluateAction(
  state: WorldState,
  action: Action
): ActionEvaluation
```

Returns:
- expected time cost
- expected outputs
- variance
- failure probability

---

### 5.2 Plan Evaluation

```ts
evaluatePlan(
  state: WorldState,
  actions: Action[]
): PlanEvaluation
```

Returns:
- total expected time
- EV of rewards
- variance profile
- constraint violations

---

## 6. Logging & Observability

Every engine call produces structured logs:

```ts
EngineLog {
  tick: number
  actor?: PlayerID
  action?: ActionID
  message: string
  data: Record<string, any>
}
```

Logs must support:
- replay
- diffing
- narrative reconstruction

---

## 7. Determinism & Replay

- Given:
  - initial WorldState
  - RNG seed
  - ordered Action list
- The engine should *mostly* reproduce identical results

Some nondeterminism (e.g. agent text) is acceptable outside the engine.

---

## 8. Explicit Non-Responsibilities

The rules engine does **not**:
- choose actions
- optimise strategies
- enforce player goals
- manage UI state
- contain narrative prose

---

## 9. v1 Simplifying Assumptions (Explicit)

For the initial implementation of the rules engine, **we intentionally choose the simplest possible semantics everywhere**, even where this is clearly unrealistic or incomplete.

These assumptions are not design commitments; they are scaffolding to get the system running and testable.

### 9.1 World & Agents
- Only **one agent acts at a time**
- Agent actions have **minimal impact on other agents**
- No contention, locking, or shared depletion

### 9.2 State & Mutation
- WorldState is **mutated in place**
- No automatic snapshotting
- Logs are the source of truth for debugging

### 9.3 Time
- Discrete time only
- One action consumes time
- No overlapping actions
- No background processes

### 9.4 Actions
- Actions are **atomic**
- Actions have **binary outcomes** (success or failure)
- No partial success
- No internal sub-actions

### 9.5 Failures
- All failures are **typed**
- Failure types are explicit and logged
- No retries or recovery baked into the engine

### 9.6 Plans
- Plans are not enforced by the engine
- Agents may submit invalid plans
- Execution proceeds action-by-action
- Invalid actions fail when reached

### 9.7 Inventory
- Inventory limits are enforced strictly
- Overflow is illegal
- No auto-dropping, spilling, or compression

### 9.8 Combat
- Combat is a single atomic action
- No multi-round or tick simulation in v1

### 9.9 RNG
- All RNG draws are explicit
- RNG is seeded
- No stochastic side channels

---

## 10. Deferred Questions (Intentionally Unanswered)

These are consciously postponed until the engine is being exercised:

- Inventory capacity model (slots vs weight)
- Combat resolution depth
- Skill progression math
- Item stat schema
- Guild reputation formulas
- Cross-agent interaction effects

The engine must be built so these can change without rewriting core infrastructure.

---

